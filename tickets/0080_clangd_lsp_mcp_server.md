# Ticket 0080: clangd LSP MCP Server

## Status
- [ ] Draft
- [ ] Design Complete — Awaiting Review
- [ ] Design Approved — Ready for Implementation
- [ ] Implementation Complete
- [ ] Quality Gate Passed — Awaiting Review
- [ ] Approved — Ready to Merge
- [ ] Merged / Complete

**Current Phase**: Draft
**Type**: Tooling / Infrastructure
**Priority**: Medium
**Created**: 2026-02-26
**Generate Tutorial**: No

---

## Summary

Build a FastMCP server that wraps clangd's LSP interface to expose live, AST-precise relational queries about the C++ codebase. AI agents can query call hierarchies, type hierarchies, references, and symbol lookups without requiring a Doxygen rebuild — the server works on the current state of the code including uncommitted changes.

---

## Problem

The existing codebase MCP server (Doxygen → SQLite) requires a build step (`cmake --build --preset doxygen-db`) to update and has limitations:

1. **Stale data** — Queries reflect the last build, not the current working tree
2. **Limited relations** — Basic call graph and symbol lookup, but no full call hierarchy (callers/callees at arbitrary depth), no type hierarchy (subtypes/supertypes), no find-all-references
3. **Doxygen parser imprecision** — Template-heavy code and complex macros can confuse Doxygen's parser, producing incomplete or incorrect results
4. **Rebuild friction** — Developers must remember to rebuild the DB after changes; agents operating on in-progress code get outdated results

clangd solves all of these — it uses the actual compiler AST, works on uncommitted code, and provides rich relational queries via the Language Server Protocol.

---

## Solution

### Architecture

```
AI Agent  →  MCP Tools  →  clangd_server.py (FastMCP)  →  LSP JSON-RPC  →  clangd subprocess
                                                                                  ↓
                                                                          compile_commands.json
                                                                                  ↓
                                                                          full AST understanding
```

### New Files

```
scripts/clangd/
├── clangd_client.py         # LSP JSON-RPC client (manages clangd subprocess)
├── clangd_server.py         # FastMCP server + CLI mode
└── symbol_resolver.py       # Name → (file, line, col) resolution via workspace/symbol
```

### MCP Tools

| Tool | LSP Method(s) | Description |
|------|--------------|-------------|
| `find_callers` | `prepareCallHierarchy` + `incomingCalls` | Who calls this function? |
| `find_callees` | `prepareCallHierarchy` + `outgoingCalls` | What does this function call? |
| `find_references` | `textDocument/references` | All usages of a symbol |
| `find_definition` | `textDocument/definition` | Where is a symbol defined? |
| `get_subtypes` | `prepareTypeHierarchy` + `subtypes` | Classes that inherit from this class |
| `get_supertypes` | `prepareTypeHierarchy` + `supertypes` | Base classes of this class |
| `get_call_graph` | Recursive `incomingCalls`/`outgoingCalls` | Call graph to configurable depth |
| `get_file_symbols` | `textDocument/documentSymbol` | All symbols defined in a file |
| `search_symbols` | `workspace/symbol` | Search symbols by name pattern |
| `get_hover_info` | `textDocument/hover` | Type information and documentation for a symbol |

### Symbol Resolution

LSP is position-based — all queries take `(file, line, column)`, not symbol names. The MCP tools accept human-friendly names (e.g., `"CollisionPipeline::execute"`) and resolve them to positions via `workspace/symbol` before forwarding to clangd. This resolution layer is the key usability bridge.

### LSP Client Design

The clangd subprocess communicates via JSON-RPC over stdin/stdout with `Content-Length` header framing. Key design considerations:

- **Async notification filtering** — clangd sends unsolicited `textDocument/publishDiagnostics` and `$/progress` notifications. The client must filter these while waiting for request responses.
- **File lifecycle management** — `textDocument/didOpen` must be sent before querying a file. Implement an LRU cache of opened files with `didClose` eviction.
- **Initialization handshake** — LSP requires `initialize` → `initialized` before any queries. Declare capabilities for `callHierarchyProvider`, `typeHierarchyProvider`, `referencesProvider`.
- **Use `lsprotocol`** — Typed Python models for all LSP messages, avoiding hand-rolled JSON-RPC parsing.

### Prerequisites

- clangd installed (comes with LLVM/clang toolchain)
- `compile_commands.json` in build directory (already generated by CMake)
- Python packages: `lsprotocol`, `fastmcp` (fastmcp already installed)

---

## Design Decisions

### DD-0080-001: Complement, don't replace, the Doxygen codebase server
**Rationale**: The Doxygen-based server excels at documentation search and broad symbol lookup across the full indexed codebase. clangd excels at precise relational queries on the live working tree. Run both — the Doxygen server for documentation and static analysis, clangd for live relational queries.

### DD-0080-002: Use `lsprotocol` over raw JSON-RPC
**Rationale**: Hand-rolling JSON-RPC message parsing is error-prone (Content-Length framing, async notifications, response correlation by ID). `lsprotocol` provides typed dataclasses for all LSP messages and handles serialization. This eliminates a class of bugs and makes the code self-documenting.

### DD-0080-003: Symbol name resolution as a separate module
**Rationale**: Every MCP tool needs to convert a human-friendly symbol name to `(file, line, col)`. Centralizing this in `symbol_resolver.py` avoids duplication and enables caching (symbol → location mappings are stable within a session unless files change). The resolver uses `workspace/symbol` and filters by symbol kind (function, class, variable) to disambiguate overloads.

### DD-0080-004: LRU file open cache with didClose eviction
**Rationale**: clangd requires `textDocument/didOpen` before any query on a file, but keeping all project files open consumes memory. An LRU cache (e.g., 50 files) balances query latency (no re-open for recently queried files) against memory usage (evicted files get `didClose`). Cache invalidation on file modification uses `textDocument/didChange` or re-open.

### DD-0080-005: Configurable call graph depth with default limit
**Rationale**: `get_call_graph` recurses through callers/callees, which can explode combinatorially. Default depth of 2 (direct callers + their callers) keeps responses manageable. The tool accepts a `depth` parameter (max 5) for deeper exploration when needed.

---

## Implementation Steps

### Phase 1: LSP Client
1. Add `lsprotocol` to `python/requirements.txt`
2. Create `scripts/clangd/clangd_client.py` — subprocess management, JSON-RPC framing, async notification filtering, initialize/shutdown lifecycle
3. Implement core LSP wrappers: `didOpen`, `didClose`, `definition`, `references`, `hover`, `documentSymbol`, `workspaceSymbol`
4. Implement call hierarchy: `prepareCallHierarchy`, `incomingCalls`, `outgoingCalls`
5. Implement type hierarchy: `prepareTypeHierarchy`, `subtypes`, `supertypes`

### Phase 2: Symbol Resolution
6. Create `scripts/clangd/symbol_resolver.py` — name-to-position resolution via `workspace/symbol`
7. Handle disambiguation (overloaded functions, same-name symbols in different namespaces)
8. Add LRU file open cache with `didClose` eviction

### Phase 3: MCP Server
9. Create `scripts/clangd/clangd_server.py` — FastMCP server with all 10 tools
10. Add CLI mode for smoke testing (same pattern as `guidelines_server.py`)
11. Register in `.mcp.json` and `.claude/settings.local.json`

### Phase 4: Integration
12. Add `lsprotocol` to `python/requirements.txt`
13. CLI smoke tests: `find_callers`, `find_references`, `get_subtypes` on known symbols
14. Verify MCP tools work from an agent session

---

## Acceptance Criteria

- [ ] `find_callers("ConstraintSolver::solve")` returns all call sites
- [ ] `find_callees("Engine::step")` returns functions called by Engine::step
- [ ] `find_references("CollisionPipeline")` returns all files referencing the class
- [ ] `get_subtypes("Constraint")` returns ContactConstraint, JointConstraint, etc.
- [ ] `get_supertypes("ContactConstraint")` returns Constraint
- [ ] `get_call_graph("CollisionPipeline::execute", direction="outgoing", depth=2)` returns a nested call tree
- [ ] `search_symbols("Pipeline")` returns all symbols matching the pattern
- [ ] `get_file_symbols("msd/msd-sim/src/Physics/Collision/CollisionPipeline.hpp")` returns all symbols in the file
- [ ] CLI mode works for all tools
- [ ] Server starts and responds within 30 seconds (including clangd indexing)
- [ ] Works on uncommitted changes without requiring a rebuild
- [ ] Graceful error when `compile_commands.json` is missing

---

## Comparison With Existing Codebase Server

| Aspect | Doxygen → SQLite (0013) | clangd LSP (this ticket) |
|--------|------------------------|--------------------------|
| Data freshness | Requires rebuild | Live, works on unsaved edits |
| Query speed | Instant (pre-indexed) | Fast after warmup (~100ms/query) |
| Startup cost | Build step required | ~10-30s indexing on first launch |
| Relations | Symbols, includes, basic call graph | Full call/type hierarchy, references |
| Precision | Doxygen parser | Full compiler AST |
| Documentation | Full Doxygen comments | Hover info only |
| Works without build | No | Needs compile_commands.json only |

**These are complementary** — both should be registered in `.mcp.json`.

---

## Dependencies

- **Requires**: clangd installed (LLVM toolchain)
- **Requires**: `compile_commands.json` (generated by CMake)
- **Nice to have**: Python `lsprotocol` package
- **Blocked By**: None

---

## Follow-Up Work

- **0080a**: Add `textDocument/diagnostic` passthrough — expose clangd diagnostics (errors, warnings) as an MCP tool for live linting without a build
- **0080b**: Add `textDocument/codeAction` passthrough — expose clangd's suggested fixes (include insertions, type corrections) as an MCP tool
- **0080c**: File watching — detect file changes and send `didChange` notifications to keep clangd's AST current during long sessions
