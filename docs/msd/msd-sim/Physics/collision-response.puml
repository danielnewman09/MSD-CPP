@startuml

' === HISTORICAL: Collision Response System ===
' This diagram documents the deprecated impulse-based collision response
' system that was REMOVED in ticket 0032d (2026-01-31).
'
' Original ticket: 0027_collision_response_system (2026-01-24)
' Removal ticket: 0032d_collision_response_cleanup (2026-01-31)
' Parent refactor: 0032_contact_constraint_refactor
'
' REPLACEMENT: Collision response is now handled by the constraint framework.
' See: two-body-constraints.puml for ContactConstraint and ContactConstraintFactory
' See: generalized-constraints.puml for ConstraintSolver

package "CollisionResponse [DEPRECATED - REMOVED 2026-01-31]" <<Cloud>> {
  class CollisionResponse <<removed>> {
    ' Stateless utility namespace for collision response calculations
    {static} + computeImpulseMagnitude(...)
    {static} + applyPositionCorrection(...)
    {static} + combineRestitution(...)
  }

  note right of CollisionResponse #FFCCCC
    REMOVED in ticket 0032d

    Replaced by:
    - ContactConstraint (non-penetration constraint)
    - ContactConstraintFactory (creates constraints from collisions)
    - ConstraintSolver::solveWithContacts() (LCP solver)

    See: two-body-constraints.puml
  end note
}

' === Current System (Post-Removal) ===

package "Constraint-Based Collision Response [CURRENT]" {
  class ContactConstraint {
    + dimension(): size_t
    + evaluateTwoBody(...): Eigen::VectorXd
    + jacobianTwoBody(...): Eigen::MatrixXd
  }

  class ContactConstraintFactory {
    {static} + createFromCollision(...): unique_ptr<ContactConstraint>
    {static} + combineRestitution(...): double
  }

  class ConstraintSolver {
    + solveWithContacts(...): MultiBodySolveResult
  }

  note bottom of ContactConstraint
    Non-penetration constraint:
    C(q) = (x_B - x_A) · n ≥ 0

    Includes:
    - Baumgarte stabilization (ERP=0.2)
    - Restitution handling (v_target = -e·v_pre)
    - Unilateral constraint (contact forces ≥ 0)
  end note
}

' === Integration with AssetInertial (unchanged) ===

class AssetInertial {
  ' Mass properties
  - mass_: double
  - inertiaTensor_: Eigen::Matrix3d
  - inverseInertiaTensor_: Eigen::Matrix3d
  - dynamicState_: InertialState
  - coefficientOfRestitution_: double
  ..
  ' Mass property accessors
  + getMass(): double
  + getInverseMass(): double
  + getInertiaTensor(): const Eigen::Matrix3d&
  + getInverseInertiaTensor(): const Eigen::Matrix3d&
  + getInertialState(): InertialState&
  ..
  ' Collision properties
  + getCoefficientOfRestitution(): double
  + setCoefficientOfRestitution(e: double)
}

class WorldModel {
  ' Simulation state
  - inertialAssets_: std::vector<AssetInertial>
  - gravity_: Coordinate
  - collisionHandler_: CollisionHandler
  - constraintSolver_: ConstraintSolver
  ..
  ' Update loop
  + update(deltaTime: milliseconds)
  + getInertialAssets(): const vector<AssetInertial>&
  ..
  ' Physics integration
  - updateCollisions()
  - updatePhysics(dt: double)
}

' === Existing Components (for context) ===

class CollisionHandler {
  + checkCollision(assetA, assetB): optional<CollisionResult>
}

struct CollisionResult {
  + normal: Coordinate
  + penetrationDepth: double
  + contactPointA: Coordinate
  + contactPointB: Coordinate
}

' === Relationships (Current System) ===

WorldModel --> CollisionHandler : uses
WorldModel --> AssetInertial : manages
WorldModel --> ConstraintSolver : owns
WorldModel ..> ContactConstraintFactory : uses

CollisionHandler ..> CollisionResult : returns
ContactConstraintFactory ..> CollisionResult : consumes
ContactConstraintFactory ..> ContactConstraint : creates
ConstraintSolver ..> ContactConstraint : solves

' === Workflow Annotations (Current System) ===

note bottom of WorldModel
  updateCollisions() workflow [CURRENT]:
  1. Iterate all inertial asset pairs (O(n²))
  2. Check collision via CollisionHandler
  3. If collision:
     a. Create ContactConstraint via ContactConstraintFactory
     b. Solve contact LCP via ConstraintSolver::solveWithContacts()
     c. Apply constraint impulses to both objects

  Migration: Ticket 0032c (2026-01-31)
  Cleanup: Ticket 0032d (2026-01-31)
end note

note bottom of ContactConstraintFactory
  Replacement for CollisionResponse utilities:
  - combineRestitution(): sqrt(e_A * e_B) [same formula]
  - createFromCollision(): One ContactConstraint per contact point

  Impulse calculation now handled by ConstraintSolver
  via Active Set Method LCP solution.
end note

@enduml
