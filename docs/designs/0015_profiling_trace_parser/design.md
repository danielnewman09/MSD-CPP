# Design: Profiling Trace Parser

## Summary

This design extends the macOS profiling infrastructure (ticket 0012) with automated trace export and JSON parsing capabilities. The implementation adds XML export functionality to `profile-instruments.sh` and introduces `parse-profile.py`, a Python script that extracts Time Profiler sample data from `.trace` files into structured JSON format. This enables programmatic analysis of profiling results, quick console summaries of performance hotspots, and lays the foundation for future CI integration and profile comparison tooling.

## Architecture Changes

### PlantUML Diagram
See: [`./0015_profiling_trace_parser.puml`](./0015_profiling_trace_parser.puml)

### New Components

#### parse-profile.py Python Script

- **Purpose**: Extract Time Profiler data from Instruments `.trace` files and output structured JSON
- **Location**: `scripts/parse-profile.py`
- **Key interfaces**:
  ```python
  #!/usr/bin/env python3
  """
  Profile Trace Parser - Extract Time Profiler data from Instruments traces.

  Ticket: 0015_profiling_trace_parser
  Design: docs/designs/0015_profiling_trace_parser/design.md
  """

  import argparse
  import json
  import subprocess
  import xml.etree.ElementTree as ET
  from pathlib import Path
  from typing import Optional

  # ANSI color codes (matching project convention)
  GREEN = '\033[0;32m'
  YELLOW = '\033[1;33m'
  RED = '\033[0;31m'
  BLUE = '\033[0;34m'
  NC = '\033[0m'

  def export_trace_to_xml(trace_file: Path) -> Path:
      """Export .trace to XML using xctrace."""

  def parse_time_profiler_xml(xml_file: Path) -> dict:
      """Parse Time Profiler XML schema to extract function samples."""

  def format_console_output(profile_data: dict, top_n: int) -> None:
      """Print color-coded table of top functions."""

  def main() -> int:
      """Main entry point."""
      parser = argparse.ArgumentParser(
          description='Extract Time Profiler data from Instruments traces.'
      )
      parser.add_argument('trace_file', type=Path)
      parser.add_argument('--output', '-o', type=Path)
      parser.add_argument('--top', type=int, default=20)
      parser.add_argument('--json-only', action='store_true')
      parser.add_argument('--no-color', action='store_true')
      # ... implementation
  ```
- **Dependencies**:
  - Python 3.9+ (stdlib only)
  - `xctrace` CLI (Xcode Command Line Tools)
  - `.trace` file from `profile-instruments.sh`
- **Thread safety**: Single-threaded script (N/A)
- **Error handling**:
  - Validates trace file exists and has `.trace` extension
  - Checks `xctrace` availability
  - Graceful failure if XML export fails (invalid trace, insufficient permissions)
  - Handles missing or malformed XML elements with warnings
  - Returns exit code 1 on fatal errors, 0 on success
- **Output format**: JSON with top N functions by sample count
  ```json
  {
    "metadata": {
      "trace_file": "profile_20260108_181837.trace",
      "template": "Time Profiler",
      "export_timestamp": "2026-01-08T18:20:00Z",
      "executable": "/path/to/msd_sim_test"
    },
    "summary": {
      "total_samples": 12345,
      "total_time_ms": 5000.0
    },
    "top_functions": [
      {
        "rank": 1,
        "name": "msd_sim::ConvexHull::computeHull<msd_sim::Coordinate>",
        "samples": 4567,
        "percentage": 37.0,
        "source_file": "ConvexHull.cpp",
        "line": 142
      }
    ]
  }
  ```

#### profile_results/ Directory Structure

- **Purpose**: Organize profiling outputs (traces, XML, JSON reports)
- **Location**: `profile_results/` (project root)
- **Organization**:
  ```
  profile_results/
  ├── profile_20260108_181837.trace
  ├── profile_20260108_181837.xml     (optional, if --export-xml used)
  └── profile_20260108_181837.json    (generated by parse-profile.py)
  ```
- **Rationale**: Mirrors `benchmark_results/` directory structure for consistency

### Modified Components

#### profile-instruments.sh Enhancement

- **Current location**: `scripts/profile-instruments.sh`
- **Changes required**:
  1. Add `--export-xml` / `-x` flag to argument parsing
  2. Add `--output-dir` / `-d` flag for custom output directory (default: `profile_results/`)
  3. Add XML export logic after successful profiling:
     ```bash
     # After xctrace record completes
     if [[ "$EXPORT_XML" == "true" ]]; then
         echo -e "${GREEN}Exporting trace to XML...${NC}"

         # Get table of contents
         xctrace export --input "$trace_file" --toc

         # Export Time Profiler data
         local xml_file="${trace_file%.trace}.xml"
         xctrace export --input "$trace_file" \
             --xpath '/trace-toc/run[@number="1"]/data/table[@schema="time-profile"]' \
             --output "$xml_file"

         if [[ -f "$xml_file" ]]; then
             echo "XML export: $xml_file"
         else
             echo -e "${YELLOW}WARNING: XML export failed${NC}"
         fi
     fi
     ```
  4. Update output directory to `profile_results/` instead of current directory
  5. Create output directory if it doesn't exist
- **Backward compatibility**:
  - `--export-xml` flag is optional (default: disabled)
  - Existing workflows without `-x` flag continue to work unchanged
  - Default output location changes from `.` to `profile_results/` (minor behavior change, improves organization)
- **Rationale**:
  - XML export is expensive (can take 10-30 seconds for large traces)
  - Make it opt-in so default profiling workflow remains fast
  - Consistent with benchmark infrastructure pattern (optional features via flags)

### Integration Points

| New Component | Existing Component | Integration Type | Notes |
|---------------|-------------------|------------------|-------|
| parse-profile.py | xctrace CLI | Subprocess invocation | Calls `xctrace export --toc` and `xctrace export --xpath` |
| parse-profile.py | profile-instruments.sh | File system (reads .trace) | Parser operates on .trace files generated by profiling script |
| profile_results/ | .gitignore | Directory exclusion | Add `profile_results/` to `.gitignore` (like `benchmark_results/`) |
| parse-profile.py | compare_benchmarks.py | Code convention alignment | Follows same Python style, argument parsing, color scheme |

## Test Impact

### Existing Tests Affected

| Test File | Test Case | Impact | Action Required |
|-----------|-----------|--------|------------------|
| None | N/A | No impact | Parser is a standalone tool, no existing tests affected |

### New Tests Required

#### Unit Tests

No unit tests required. This is a developer tool script, validated through manual execution and prototyping.

#### Integration Tests

No integration tests required. Parser success can be validated by:
1. Running profiling workflow
2. Verifying JSON output is well-formed
3. Checking that function names appear (not just addresses)

#### Validation Approach

| Component | Validation Method | Success Criteria |
|-----------|------------------|------------------|
| XML export | Manual execution with --export-xml | XML file created with Time Profiler schema |
| parse-profile.py | Parse real trace file | JSON output generated with top functions |
| xctrace schema | Parse actual trace from msd_sim_bench | Function names (not addresses) appear in JSON |
| Console output | Run without --json-only | Color-coded table printed to console |
| Error handling | Run on missing/invalid trace | Graceful error message, exit code 1 |

### Prototype Required

See "Open Questions" section for prototype validation of xctrace XML schema parsing.

## Implementation Phases

### Phase 1: profile-instruments.sh Enhancement

**Goal**: Add XML export capability and output directory management

**Tasks**:
1. Add `--export-xml` / `-x` flag to argument parsing
2. Add `--output-dir` / `-d` flag with default `profile_results/`
3. Create output directory if it doesn't exist
4. Move trace file generation to output directory
5. Implement XML export logic (conditional on `-x` flag)
6. Update usage message with new flags
7. Test with msd_sim_bench:
   ```bash
   ./scripts/profile-instruments.sh ./build/Release/release/msd_sim_bench --export-xml
   ```

**Acceptance**:
- Script creates `profile_results/` directory
- Trace file saved to `profile_results/profile_YYYYMMDD_HHMMSS.trace`
- XML file saved to `profile_results/profile_YYYYMMDD_HHMMSS.xml` (only with `-x`)
- Existing workflows without `-x` continue to work

### Phase 2: parse-profile.py Core Implementation

**Goal**: Create parser that extracts Time Profiler data to JSON

**Tasks**:
1. Create `scripts/parse-profile.py` with proper shebang and docstring
2. Implement argument parsing (trace_file, --output, --top, --json-only, --no-color)
3. Implement `export_trace_to_xml()` function:
   - Call `xctrace export --toc` to discover tables
   - Call `xctrace export --xpath` to extract Time Profiler schema
   - Return path to XML file
4. Implement `parse_time_profiler_xml()` function:
   - Parse XML using `xml.etree.ElementTree`
   - Extract sample counts per function
   - Calculate percentages relative to total samples
   - Demangle C++ symbols if available
   - Extract source file and line info when present
5. Implement JSON schema generation
6. Implement `format_console_output()` for human-readable summary
7. Make script executable: `chmod +x scripts/parse-profile.py`

**Acceptance**:
- Parser accepts `.trace` file and generates JSON
- JSON contains metadata, summary, and top_functions array
- Function names appear (not raw addresses)
- Script runs in under 2 seconds for typical traces

### Phase 3: Error Handling and Edge Cases

**Goal**: Robust error handling for production use

**Tasks**:
1. Validate trace file exists and has `.trace` extension
2. Check `xctrace` availability (same as profile-instruments.sh)
3. Handle XML export failures gracefully
4. Handle missing XML elements (malformed schema)
5. Handle empty profiles (no samples collected)
6. Provide clear error messages with suggested actions
7. Test error scenarios:
   - Missing trace file
   - Invalid trace file (corrupted)
   - Empty trace (no samples)
   - Missing xctrace

**Acceptance**:
- All error cases produce clear messages
- Exit code 1 on fatal errors
- No Python stack traces for expected errors
- Errors match color scheme and style of existing scripts

### Phase 4: Documentation and Integration

**Goal**: Document parser usage and update CLAUDE.md

**Tasks**:
1. Update `CLAUDE.md` with profiling parser section
2. Add parser usage examples
3. Add JSON schema documentation
4. Add to `.gitignore`: `profile_results/`
5. Document profiling + parsing workflow
6. Add troubleshooting section for common issues

**Acceptance**:
- CLAUDE.md includes comprehensive parser documentation
- Examples cover common use cases (tests, benchmarks, executables)
- JSON schema fully documented
- Workflow from profiling → parsing → analysis is clear

## JSON Output Schema

### Metadata Section

```json
"metadata": {
  "trace_file": "profile_20260108_181837.trace",
  "template": "Time Profiler",
  "export_timestamp": "2026-01-08T18:20:00Z",
  "executable": "/absolute/path/to/executable"
}
```

**Fields**:
- `trace_file`: Original `.trace` filename (not full path)
- `template`: Instruments template used (always "Time Profiler" for v1)
- `export_timestamp`: ISO 8601 timestamp when JSON was generated
- `executable`: Full path to profiled executable (extracted from trace metadata)

### Summary Section

```json
"summary": {
  "total_samples": 12345,
  "total_time_ms": 5000.0
}
```

**Fields**:
- `total_samples`: Total sample count across all functions
- `total_time_ms`: Approximate profiling duration in milliseconds (calculated from sample rate)

**Note**: Instruments Time Profiler samples at ~1ms intervals. `total_time_ms` is an estimate derived from sample count.

### Top Functions Array

```json
"top_functions": [
  {
    "rank": 1,
    "name": "msd_sim::ConvexHull::computeHull<msd_sim::Coordinate>",
    "samples": 4567,
    "percentage": 37.0,
    "source_file": "ConvexHull.cpp",
    "line": 142
  }
]
```

**Fields**:
- `rank`: Position in top-N list (1-indexed)
- `name`: Demangled function name (C++ symbols decoded)
- `samples`: Number of samples where this function was on the stack
- `percentage`: Percent of total samples (rounded to 1 decimal place)
- `source_file`: Source filename (if available in debug symbols, otherwise null)
- `line`: Line number (if available, otherwise null)

**Sorting**: Functions sorted by sample count descending (highest first)

## Console Output Format

When not using `--json-only`, the parser prints a color-coded table:

```
Profiling Summary: profile_20260108_181837.trace
Executable: /path/to/msd_sim_bench
Total Samples: 12,345 (~5,000 ms)

┌──────────────────────────────────────────────────────┬─────────┬───────────┬──────────────────┐
│ Function                                             │ Samples │ Percent   │ Source           │
├──────────────────────────────────────────────────────┼─────────┼───────────┼──────────────────┤
│ msd_sim::ConvexHull::computeHull<Coordinate>         │   4,567 │ 37.0%     │ ConvexHull.cpp   │
│ msd_sim::ConvexHull::signedDistance                  │   2,345 │ 19.0%     │ ConvexHull.cpp   │
│ Qhull::qh_new_qhull                                  │   1,234 │ 10.0%     │ libqhull.a       │
│ ...                                                  │   ...   │ ...       │ ...              │
└──────────────────────────────────────────────────────┴─────────┴───────────┴──────────────────┘

Top hotspot: ConvexHull::computeHull (37.0% of samples)

JSON report: profile_results/profile_20260108_181837.json
```

**Color scheme** (matches existing scripts):
- BLUE: Headers and informational text
- GREEN: Success messages
- YELLOW: Warnings
- RED: Errors

## xctrace XML Schema (Time Profiler)

### Discovering Available Tables

```bash
xctrace export --input profile.trace --toc
```

**Output** (abbreviated):
```xml
<trace-toc>
  <run number="1" duration-ms="5234">
    <data>
      <table schema="time-profile">
        <id>0</id>
        <title>Time Profiler</title>
      </table>
      <table schema="backtrace-repository">
        <id>1</id>
        <title>Call Tree</title>
      </table>
    </data>
  </run>
</trace-toc>
```

### Extracting Time Profiler Data

```bash
xctrace export --input profile.trace \
    --xpath '/trace-toc/run[@number="1"]/data/table[@schema="time-profile"]' \
    --output profile.xml
```

**Expected XML structure**:
```xml
<trace-query-result>
  <node id="1" weight="4567" name="msd_sim::ConvexHull::computeHull">
    <process pid="12345" />
    <backtrace id="1234" />
    <source-location file="ConvexHull.cpp" line="142" />
  </node>
  <node id="2" weight="2345" name="msd_sim::ConvexHull::signedDistance">
    <process pid="12345" />
    <backtrace id="1235" />
    <source-location file="ConvexHull.cpp" line="87" />
  </node>
  <!-- ... more nodes ... -->
</trace-query-result>
```

**Key fields**:
- `node/@weight`: Sample count for this function
- `node/@name`: Function name (may be mangled or demangled depending on Xcode version)
- `source-location/@file`: Source filename (if debug symbols present)
- `source-location/@line`: Line number (if debug symbols present)

### Schema Variations by Xcode Version

| Xcode Version | Schema Differences | Mitigation |
|---------------|-------------------|------------|
| 13.0 - 14.0 | May include mangled symbols | Demangle with `c++filt` if needed |
| 14.0+ | Usually includes demangled symbols | Use as-is |
| All | Source location may be missing | Handle gracefully, set to null in JSON |
| All | XML structure may vary slightly | Parse defensively with optional fields |

**Design principle**: Parse defensively, handle missing elements gracefully, emit warnings for unexpected schema.

## Open Questions

### Design Decisions (Human Input Needed)

1. **Output directory default behavior**
   - Option A: Always use `profile_results/` (change from current directory)
   - Option B: Add `--output-dir` flag but default to current directory (backward compatible)
   - Recommendation: Option A — Consistent with benchmark infrastructure, improves organization
   - **Status**: Approved by human (ticket specifies `profile_results/`)

2. **Symbol demangling strategy**
   - Option A: Use `c++filt` subprocess if symbols are mangled
   - Option B: Rely on xctrace providing demangled symbols
   - Option C: Include both mangled and demangled in JSON
   - Recommendation: Option B initially, fall back to Option A if Xcode versions vary. Option C adds unnecessary complexity.

3. **Call tree vs. flat function list**
   - Option A: Flat function list (sum of all samples per function)
   - Option B: Hierarchical call tree (shows caller/callee relationships)
   - Recommendation: Option A — Simpler implementation, sufficient for hotspot identification. Defer call tree to future enhancement.
   - **Status**: Approved by human (ticket specifies defer call tree)

4. **Comparison tool scope**
   - Option A: Include basic profile comparison in this ticket
   - Option B: Defer comparison to future ticket (like benchmark comparison)
   - Recommendation: Option B — Keeps ticket focused, allows comparison tool to leverage lessons from benchmark comparison tool
   - **Status**: Approved by human (ticket specifies defer comparison tool)

### Prototype Required

1. **Validate xctrace XML export schema**
   - Uncertainty: What is the exact XML structure for Time Profiler output? Does it vary by Xcode version?
   - Validation: Run xctrace export on an actual trace file and inspect XML structure
   - Acceptance: XML contains sample weights, function names, source locations

2. **Verify symbol resolution in XML**
   - Uncertainty: Are function names demangled in XML output, or do we need to call `c++filt`?
   - Validation: Profile msd_sim_bench, export XML, check if symbols are demangled
   - Acceptance: Function names are human-readable (not mangled like `_ZN7msd_sim10ConvexHull11computeHullEv`)

3. **Test XML export performance**
   - Uncertainty: How long does XML export take for typical traces?
   - Validation: Time `xctrace export` on a 5-second profiling session
   - Acceptance: Export completes in under 30 seconds

### Requirements Clarification

1. **JSON output location**: Should JSON always go to `profile_results/`, or allow custom location via `--output`?
   - Assumption: Allow custom location via `--output`, default to `profile_results/` with same base name as trace file
   - **Status**: Approved by human (ticket specifies `profile_results/`)

2. **Handling non-Time Profiler traces**: Should parser fail gracefully on Allocations/Leaks traces?
   - Assumption: Detect template type from TOC, fail with clear message if not Time Profiler

3. **Top-N default**: Is 20 functions a reasonable default?
   - Assumption: Yes, based on common practice. Most performance issues visible in top 10-20 functions.

4. **XML cleanup**: Should parser delete XML file after parsing?
   - Assumption: Keep XML file for debugging. User can delete manually if disk space is a concern.

## Future Enhancements

### Profile Comparison Tool

Create `compare-profiles.py` similar to `compare_benchmarks.py`:
- Compare two profile JSON files
- Detect performance regressions (function X got slower)
- Output diff table showing before/after sample counts
- Integrate with CI for regression detection

### Allocations Template Support

Extend parser to handle Allocations template:
- Different XML schema (allocation sizes, not sample counts)
- JSON output includes memory allocations by function
- Console output shows top memory consumers

### Call Tree Analysis

Enhance JSON schema to include hierarchical call tree:
- Parent/child relationships between functions
- Attribution: which callers contribute most samples
- Flame graph generation for visualization

### Automated Profiling in CI

Integrate profiling into CI pipeline:
- Profile test/benchmark executables automatically
- Generate JSON reports
- Compare against baseline
- Fail build on significant performance regressions

### Profiling Multi-Run Analysis

Support profiling multiple runs and aggregating results:
- Run executable N times under profiler
- Average sample counts across runs
- Calculate variance to identify flaky hotspots

## Implementation Guidance

### Error Message Style

Follow existing script conventions:

```python
# GOOD - Clear, actionable error messages
print(f"{RED}ERROR: Trace file not found: {trace_file}{NC}", file=sys.stderr)
print("Run profiling first:", file=sys.stderr)
print("  ./scripts/profile-instruments.sh <executable> --export-xml", file=sys.stderr)

# BAD - Bare exception without context
raise FileNotFoundError(trace_file)
```

### Defensive XML Parsing

Handle missing elements gracefully:

```python
# GOOD - Defensive parsing with defaults
def parse_node(node: ET.Element) -> dict:
    name = node.get('name', '<unknown>')
    weight = int(node.get('weight', 0))

    # Source location may be missing
    source_loc = node.find('source-location')
    source_file = source_loc.get('file', None) if source_loc is not None else None
    line = int(source_loc.get('line', 0)) if source_loc is not None else None

    return {
        'name': name,
        'samples': weight,
        'source_file': source_file,
        'line': line if line else None
    }

# BAD - Assumes all elements exist
def parse_node_bad(node: ET.Element) -> dict:
    return {
        'name': node['name'],  # KeyError if missing
        'samples': int(node['weight']),
        'source_file': node.find('source-location')['file']  # TypeError if None
    }
```

### Python Type Hints

Use modern generics (Python 3.9+):

```python
# GOOD - Python 3.9+ built-in generics
def parse_functions(xml_file: Path) -> list[dict]:
    functions: list[dict] = []
    # ...
    return functions

# BAD - Old typing module imports (unnecessary in 3.9+)
from typing import List, Dict

def parse_functions(xml_file: Path) -> List[Dict[str, Any]]:
    # ...
```

## References

- Ticket: `tickets/0015_profiling_trace_parser.md`
- Parent design: `docs/designs/0012_add_macos_profiling_support/design.md`
- Related: `docs/designs/0014_benchmark_metrics_tracker/design.md` (comparison tool pattern)
- xctrace man page: `man xctrace`
- Python XML parsing: https://docs.python.org/3/library/xml.etree.elementtree.html

---

## Design Review

**Reviewer**: Design Review Agent
**Date**: 2026-01-08
**Status**: APPROVED
**Iteration**: 0 of 1 (no revision needed)

### Criteria Assessment

#### Architectural Fit

| Criterion | Pass/Fail | Notes |
|-----------|-----------|-------|
| Naming conventions | ✓ | Script name `parse-profile.py` follows existing `compare_benchmarks.py` pattern. Function names use snake_case per Python convention. Color constants match existing scripts exactly (GREEN, YELLOW, RED, BLUE, NC). |
| Namespace organization | N/A | Python script, no C++ namespaces. |
| File structure | ✓ | Script in `scripts/` matches project organization. Design docs in `docs/designs/0015_profiling_trace_parser/` follow convention. Output to `profile_results/` mirrors `benchmark_results/` structure. |
| Dependency direction | ✓ | Clean dependency flow: parse-profile.py → xctrace → trace files. No circular dependencies. Parser is standalone and doesn't modify profiling infrastructure. |

#### C++ Design Quality

| Criterion | Pass/Fail | Notes |
|-----------|-----------|-------|
| RAII usage | N/A | Python script, no RAII. File handles managed by context managers (implicit). |
| Smart pointer appropriateness | N/A | Python script, no smart pointers. |
| Value/reference semantics | N/A | Python script, uses references by default. |
| Rule of 0/3/5 | N/A | Python script, no special member functions. |
| Const correctness | N/A | Python script, no const qualifier. |
| Exception safety | N/A | Python script, uses exit codes for errors (Pythonic approach). |
| Initialization | ✓ | Uses Python 3.9+ type hints (`list[dict]` not `List[Dict]`). Follows modern Python conventions. |
| Return values | ✓ | Functions return values/dicts rather than modifying parameters. Follows functional style. |

**Note**: This design creates Python tooling, not C++ code. C++ design quality criteria are not applicable. Python code follows modern Python 3.9+ conventions and matches existing project scripts.

#### Feasibility

| Criterion | Pass/Fail | Notes |
|-----------|-----------|-------|
| Header dependencies | N/A | Python script, no headers. |
| Template complexity | N/A | Python script, no templates. |
| Memory strategy | ✓ | Uses Python stdlib only (xml.etree, json, subprocess, pathlib, argparse). No external dependencies. Memory managed by Python runtime. Defensive XML parsing prevents unbounded memory use. |
| Thread safety | ✓ | Single-threaded script. No concurrency concerns. |
| Build integration | ✓ | No build system changes required. Script is standalone executable. Only needs `chmod +x`. Integrates with existing profiling workflow via file system (reads .trace files). |

#### Testability

| Criterion | Pass/Fail | Notes |
|-----------|-----------|-------|
| Isolation possible | ✓ | Parser operates on .trace files independently. Can be tested with pre-generated trace files. No coupling to profiling execution. |
| Mockable dependencies | ✓ | xctrace subprocess calls can be mocked for testing. XML parsing can be tested with fixture files. |
| Observable state | ✓ | Success observable via: (1) JSON file creation, (2) JSON schema validation, (3) exit code 0/1, (4) console output. All outputs are files or stdout/stderr. |

### Risks Identified

| ID | Risk Description | Category | Likelihood | Impact | Mitigation | Prototype? |
|----|------------------|----------|------------|--------|------------|------------|
| R1 | xctrace XML schema may vary between Xcode versions, breaking parser | Technical | Medium | High | Parse defensively with optional fields, emit warnings for unexpected elements, provide clear error messages. Validate with prototype on current Xcode version. | Yes |
| R2 | Symbol demangling may not be automatic, requiring c++filt subprocess | Technical | Low | Low | Design includes fallback strategy to c++filt if symbols are mangled. Check with prototype first. | Yes |
| R3 | XML export may be prohibitively slow for large traces | Performance | Low | Medium | Make XML export opt-in via --export-xml flag. Parser can call xctrace internally if needed. Document expected export times. | Yes |
| R4 | Backward compatibility: changing default output from `.` to `profile_results/` | Integration | Low | Low | Clearly document behavior change in CLAUDE.md. Provide --output-dir flag for customization. Follows established pattern from benchmark infrastructure. | No |

### Prototype Guidance

#### Prototype P1: Validate xctrace XML Schema Parsing

**Risk addressed**: R1, R2
**Question to answer**: What is the exact XML structure output by `xctrace export` for Time Profiler data? Are function names demangled? Do source locations appear?

**Success criteria**:
- xctrace export produces valid XML
- XML contains `<node>` elements with `weight` attribute (sample counts)
- Function names are present in `name` attribute
- Function names are demangled (e.g., `msd_sim::ConvexHull::computeHull`, not `_ZN...`)
- Source location elements exist (when debug symbols present)
- XML schema is parseable with xml.etree.ElementTree

**Prototype approach**:
```
Location: prototypes/0015_profiling_trace_parser/p1_xctrace_schema/
Type: Manual validation with existing executables

Steps:
1. Build msd_sim_bench with profiling flags:
   conan install . --build=missing -s build_type=Release -o "&:enable_profiling=True"
   cmake --preset profiling-release -DENABLE_PROFILING=ON
   cmake --build --preset conan-release --target msd_sim_bench

2. Profile a short run:
   ./scripts/profile-instruments.sh ./build/Release/release/msd_sim_bench
   (Let it run for 3-5 seconds, then Ctrl-C)

3. Export to XML:
   xctrace export --input profile_results/profile_*.trace --toc > toc.txt
   xctrace export --input profile_results/profile_*.trace \
       --xpath '/trace-toc/run[@number="1"]/data/table[@schema="time-profile"]' \
       --output test_export.xml

4. Inspect XML structure:
   head -50 test_export.xml
   grep '<node' test_export.xml | head -10

5. Validate key elements present:
   - <node> elements with weight attribute
   - Function names in name attribute (check if demangled)
   - <source-location> elements with file and line attributes

6. Test parsing with Python:
   python3 -c "
   import xml.etree.ElementTree as ET
   tree = ET.parse('test_export.xml')
   root = tree.getroot()
   nodes = root.findall('.//node')
   print(f'Found {len(nodes)} nodes')
   for node in nodes[:5]:
       print(f\"  {node.get('name')} - {node.get('weight')} samples\")
       src = node.find('source-location')
       if src is not None:
           print(f\"    {src.get('file')}:{src.get('line')}\")
   "

7. Document findings:
   - XML structure (create schema documentation)
   - Whether symbols are demangled
   - Whether source locations are present
```

**Time box**: 45 minutes

**If prototype fails**:
- **No XML export**: xctrace version too old. Document minimum macOS/Xcode version requirement. Consider alternative approaches (parse .trace binary format, or GUI-only workflow).
- **Mangled symbols**: Add c++filt demangling step in parser implementation.
- **Missing source locations**: Make source_file and line optional in JSON schema (already planned).
- **Unexpected XML structure**: Update design document with actual schema, adjust parser implementation.

#### Prototype P2: Test XML Export Performance

**Risk addressed**: R3
**Question to answer**: How long does `xctrace export` take for typical profiling sessions (5s, 30s, 60s)?

**Success criteria**:
- Export time is reasonable (< 30 seconds for 5-second profile)
- Export time scales linearly with trace duration
- Export doesn't consume excessive disk space

**Prototype approach**:
```
Location: prototypes/0015_profiling_trace_parser/p2_export_performance/
Type: Manual timing measurements

Steps:
1. Create traces of varying lengths:
   ./scripts/profile-instruments.sh ./build/Release/release/msd_sim_bench
   (Run for 5s, 15s, 30s - Ctrl-C to stop)

2. Time XML export for each:
   for trace in profile_results/profile_*.trace; do
       echo "Exporting $trace..."
       time xctrace export --input "$trace" \
           --xpath '/trace-toc/run[@number="1"]/data/table[@schema="time-profile"]' \
           --output "${trace%.trace}.xml"
       ls -lh "${trace%.trace}.xml"
   done

3. Document results:
   - Export time vs. trace duration
   - XML file size vs. trace file size
   - Memory usage during export (Activity Monitor)

4. Determine if export is fast enough for default behavior or should be opt-in
```

**Time box**: 20 minutes

**If prototype fails**:
- **Export too slow**: Keep XML export as opt-in via --export-xml flag (already planned). Parser calls xctrace internally when needed.
- **Disk space excessive**: Add warning in documentation about XML file sizes.
- **Export crashes**: Add error handling for export failures, provide clear error messages.

### Summary

This design is **APPROVED** with two straightforward validation prototypes. The design demonstrates excellent adherence to project patterns and provides practical profiling workflow enhancements:

**Strengths:**
1. **Follows established patterns**: Mirrors benchmark infrastructure exactly (Python script conventions, color scheme, JSON output, directory structure)
2. **Minimal dependencies**: Python stdlib only, no external packages required
3. **Defensive design**: Comprehensive error handling, graceful degradation for missing XML elements
4. **Clear separation of concerns**: Parser is standalone, doesn't modify profiling infrastructure
5. **Backward compatible**: Optional XML export flag, existing workflows unaffected
6. **Well-documented**: Clear JSON schema, console output format, implementation phases
7. **Practical implementation guidance**: Defensive XML parsing examples, error message conventions

**Design quality indicators:**
- Appropriate use of Python 3.9+ features (modern type hints)
- Follows project-wide script conventions (compare_benchmarks.py, run_benchmarks.sh)
- Clear dependency flow (no circular dependencies)
- Opt-in features for expensive operations (--export-xml flag)
- Comprehensive error handling strategy
- JSON schema matches benchmark report format for consistency

**Prototypes required**: Two validation prototypes (45 min + 20 min = 65 min total) to confirm:
1. xctrace XML schema structure and symbol demangling
2. XML export performance characteristics

Both prototypes are manual validation using existing infrastructure and have clear fallback strategies. The design is fundamentally sound and ready for prototype validation.

**Architecture assessment**: This is a pure Python tooling enhancement with no C++ code changes. The design integrates cleanly with existing profiling infrastructure, follows project conventions, and provides a solid foundation for future enhancements (profile comparison, CI integration).

**Next steps:**
1. Human reviews this approval
2. Execute P1 and P2 prototypes (65 minutes total)
3. Document prototype results in design document
4. Proceed to implementation phase if prototypes pass
5. Update design if prototypes reveal schema variations or performance issues
