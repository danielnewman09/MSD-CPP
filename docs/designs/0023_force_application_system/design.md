# Design: Force Application System for Rigid Body Physics

## Summary

This design completes the force application system scaffolded in ticket 0023a by implementing the physics logic: torque computation in `applyForceAtPoint()`, semi-implicit Euler integration in `WorldModel::updatePhysics()`, and synchronization between `ReferenceFrame` and `InertialState`. With angular types already migrated (ticket 0024), this ticket focuses solely on implementing the actual physics integration to enable realistic rigid body dynamics including gravity, forces at arbitrary points, and torque application.

## Architecture Changes

### PlantUML Diagram
See: `./0023_force_application_system.puml`

### Modified Components

#### AssetInertial

**Current location**: `msd/msd-sim/src/Physics/RigidBody/AssetInertial.hpp`, `AssetInertial.cpp`

**Changes required**:
1. Complete `applyForceAtPoint()` to compute torque from `r × F`
2. No new members needed (scaffolding from ticket 0023a is complete)

**Rationale**: The scaffolding provided the API and accumulation logic. This ticket completes the physics by adding torque computation when forces are applied at points offset from the center of mass.

**Backward compatibility**: **Non-breaking** — Completes existing placeholder implementation.

**Modified implementation**:
```cpp
// msd/msd-sim/src/Physics/RigidBody/AssetInertial.cpp

void AssetInertial::applyForceAtPoint(const Coordinate& force,
                                      const Coordinate& worldPoint) {
  // Accumulate linear force
  accumulatedForce_ += force;

  // Compute torque: τ = r × F
  // r is the vector from center of mass to application point
  Coordinate r = worldPoint - getReferenceFrame().getOrigin();
  Coordinate torque = r.cross(force);

  // Accumulate torque
  accumulatedTorque_ += torque;

  // Ticket: 0023_force_application_system
}
```

**Key physics**:
- Torque generated by offset force: `τ = r × F`
- `r` is displacement vector from center of mass to application point
- Cross product gives torque magnitude and direction (right-hand rule)
- Force at center of mass generates zero torque (r = 0)

---

#### WorldModel

**Current location**: `msd/msd-sim/src/Environment/WorldModel.hpp`, `WorldModel.cpp`

**Changes required**:
1. Implement `updatePhysics(double dt)` with semi-implicit Euler integration
2. Synchronize `ReferenceFrame` with updated `InertialState`
3. Apply gravity to all inertial assets
4. No new members needed (gravity_ already added in ticket 0023a)

**Rationale**: Semi-implicit Euler (velocity-first integration) provides better numerical stability than explicit Euler, especially for oscillatory systems like rotational dynamics. The order matters: updating velocity before position uses the new velocity, reducing energy drift.

**Backward compatibility**: **Non-breaking** — Replaces placeholder implementation.

**Modified implementation**:
```cpp
// msd/msd-sim/src/Environment/WorldModel.cpp

void WorldModel::updatePhysics(double dt) {
  for (auto& asset : inertialAssets_) {
    // ===== Apply Gravity =====
    // F_gravity = m * g (where g is acceleration vector)
    Coordinate gravityForce = gravity_ * asset.getMass();
    asset.applyForce(gravityForce);

    // ===== Linear Integration (Semi-Implicit Euler) =====
    // Get accumulated forces
    const Coordinate& netForce = asset.getAccumulatedForce();

    // Compute linear acceleration: a = F_net / m
    Coordinate linearAccel = netForce / asset.getMass();

    // Update velocity: v_new = v_old + a * dt
    InertialState& state = asset.getInertialState();
    state.velocity += linearAccel * dt;
    state.acceleration = linearAccel;

    // Update position using NEW velocity: x_new = x_old + v_new * dt
    state.position += state.velocity * dt;

    // ===== Angular Integration (Semi-Implicit Euler) =====
    // Get accumulated torque
    const Coordinate& netTorque = asset.getAccumulatedTorque();

    // Compute angular acceleration: α = I⁻¹ * τ
    msd_sim::Vector3D angularAccel = asset.getInverseInertiaTensor() * netTorque;

    // Update angular velocity: ω_new = ω_old + α * dt
    AngularRate& omega = state.angularVelocity;
    omega += angularAccel * dt;
    state.angularAcceleration = AngularRate{angularAccel};

    // Update orientation: θ_new = θ_old + ω_new * dt
    state.orientation += omega * dt;

    // ===== Synchronize ReferenceFrame =====
    // ReferenceFrame must match InertialState for collision detection
    // and rendering to work correctly
    ReferenceFrame& frame = asset.getReferenceFrame();
    frame.setOrigin(state.position);
    frame.setRotation(state.orientation);

    // ===== Clear Forces for Next Frame =====
    asset.clearForces();
  }
  // Ticket: 0023_force_application_system
}
```

**Semi-Implicit Euler Advantages**:
- **Velocity-first**: Update velocity with acceleration, then position with new velocity
- **Better stability**: Reduces energy drift in oscillatory systems (pendulums, rotations)
- **Simple**: Only requires one derivative evaluation per step
- **Industry standard**: Used in game engines (Unity, Unreal) and rigid body libraries (Bullet)

**Integration order matters**:
```
Explicit Euler (unstable):     Semi-Implicit Euler (stable):
  x_new = x_old + v_old * dt     v_new = v_old + a * dt
  v_new = v_old + a * dt         x_new = x_old + v_new * dt
```

**Synchronization necessity**:
- `ReferenceFrame` is used by GJK for collision detection in world space
- `ReferenceFrame` is used by rendering for object transforms
- `InertialState` is used by physics integration
- Must keep them synchronized after each physics step

---

### Integration Points

| Modified Component | Integration Type | Notes |
|--------------------|------------------|-------|
| AssetInertial.applyForceAtPoint() | Physics logic completion | Adds torque computation using cross product |
| WorldModel.updatePhysics() | Physics integration | Implements semi-implicit Euler, applies gravity, synchronizes frames |
| ReferenceFrame synchronization | State management | Ensures collision/rendering use physics-updated transforms |

---

## Test Impact

### Existing Tests Affected

| Test File | Test Case | Impact | Action Required |
|-----------|-----------|--------|------------------|
| `msd/msd-sim/test/Physics/RigidBody/AssetInertialTest.cpp` | Existing force accumulation tests | Non-breaking | Tests should continue to pass; torque now computed in applyForceAtPoint |
| `msd/msd-sim/test/Environment/WorldModelTest.cpp` | Existing updatePhysics tests | Non-breaking | Physics integration now functional instead of placeholder |

### New Tests Required

#### Unit Tests

| Component | Test Case | What It Validates |
|-----------|-----------|-------------------|
| AssetInertial | `applyForceAtPoint_generatesTorque` | Force at offset point generates correct torque via r × F |
| AssetInertial | `applyForceAtPoint_atCenterOfMass_zeroTorque` | Force at center of mass generates zero torque |
| AssetInertial | `applyForceAtPoint_torqueDirection` | Torque direction follows right-hand rule |
| WorldModel | `updatePhysics_appliesGravity` | Objects fall under gravity when no other forces applied |
| WorldModel | `updatePhysics_semiImplicitEuler` | Velocity updated before position (semi-implicit order) |
| WorldModel | `updatePhysics_synchronizesReferenceFrame` | ReferenceFrame position/orientation match InertialState after integration |
| WorldModel | `updatePhysics_clearsForces` | Forces cleared after integration |

#### Integration Tests

| Test Case | Components Involved | What It Validates |
|-----------|---------------------|-------------------|
| `projectileMotion` | WorldModel, AssetInertial | Object follows parabolic trajectory under gravity |
| `rotationFromOffsetForce` | WorldModel, AssetInertial | Object rotates when force applied at offset point |
| `multipleForces_accumulate` | WorldModel, AssetInertial | Multiple forces per frame accumulate correctly before integration |
| `energyConservation_freefall` | WorldModel, AssetInertial | Kinetic + potential energy roughly conserved in freefall (within numerical error) |

#### Benchmark Tests (Performance-Critical)

| Component | Benchmark Case | What It Measures | Baseline Expectation |
|-----------|----------------|------------------|----------------------|
| WorldModel | `updatePhysics_1000objects` | Physics integration throughput | ~1-2ms for 1000 objects at 60 FPS |
| AssetInertial | `applyForceAtPoint_crossProduct` | Torque computation overhead | < 10 ns per call (should be negligible) |

**Rationale for benchmarks**: Physics integration runs every frame (60 FPS = 16.67ms budget). With 1000 objects, physics should consume < 10% of frame time to leave room for rendering and collision detection.

---

## Open Questions

### Design Decisions (Human Input Needed)

**None** — All design decisions have been made:
- Semi-implicit Euler integration (confirmed in ticket)
- Gravity as acceleration, not per-object force (confirmed in ticket)
- World-space forces and torques (confirmed in ticket)
- ReferenceFrame synchronization after integration (required for consistency)

### Prototype Required

**None** — Physics integration algorithms are well-established:
- Semi-implicit Euler is standard in rigid body simulation
- Cross product for torque is fundamental physics
- No uncertain behavior to validate

### Requirements Clarification

**None** — Requirements are clear from ticket 0023:
- Implement torque computation in applyForceAtPoint()
- Implement semi-implicit Euler in updatePhysics()
- Synchronize ReferenceFrame with InertialState
- Objects must fall under gravity

---

## Implementation Notes

### Numerical Stability Considerations

**Semi-Implicit Euler Energy Drift**:
- Energy is not perfectly conserved (numerical integrator limitation)
- Expect ~1-2% energy drift over long simulations
- Acceptable for game/visualization applications
- For high-precision simulations, future ticket could implement RK4 or symplectic integrators

**Timestep Requirements**:
- Integration stability depends on `dt` size
- Recommended: 60 FPS (dt = 16.67ms) or higher
- Smaller timesteps = better accuracy but higher computational cost
- Future enhancement: adaptive timestep based on object velocities

### Cross Product for Torque

The cross product `r × F` gives torque magnitude and direction:
```
Magnitude: |τ| = |r| * |F| * sin(θ)
Direction: Right-hand rule (thumb = r, fingers = F, palm = τ)
```

**Edge cases**:
- Force at center of mass: `r = 0` → `τ = 0` (correct)
- Force parallel to r: `sin(θ) = 0` → `τ = 0` (correct)
- Force perpendicular to r: `sin(θ) = 1` → maximum torque (correct)

### Coordinate System Consistency

All quantities are in **world space**:
- Forces: world-space vectors [N]
- Torques: world-space vectors [N·m]
- Application points: world-space positions [m]
- Gravity: world-space acceleration [m/s²]

**Rationale**: Simplifies force application API (caller doesn't need to transform to body space). Physics integration handles world-space forces directly.

### Inertia Tensor Usage

The inertia tensor `I` relates angular momentum `L` to angular velocity `ω`:
```
L = I * ω
τ = dL/dt = I * α  (for constant I)
α = I⁻¹ * τ
```

**Why inverse tensor**:
- Computing `α` from `τ` requires matrix inversion
- AssetInertial caches `I⁻¹` to avoid per-frame inversion
- One-time cost at construction vs. per-frame cost during integration

### ReferenceFrame Synchronization Timing

Synchronization happens **after** integration:
1. Physics updates `InertialState` position and orientation
2. `ReferenceFrame` is updated to match
3. Next frame, collision detection uses updated `ReferenceFrame`
4. Rendering uses updated `ReferenceFrame`

**Why not bidirectional**:
- `InertialState` is the source of truth for physics
- `ReferenceFrame` is a derived representation for transforms
- One-way sync prevents conflicting updates

---

## Physics Validation

### Expected Behaviors

**Gravity (No Air Resistance)**:
```
Free fall from height h:
  Position: y(t) = h - 0.5 * g * t²
  Velocity: v(t) = -g * t
  Time to ground: t = sqrt(2*h/g)
```

**Projectile Motion**:
```
Initial velocity v₀ at angle θ:
  x(t) = v₀ * cos(θ) * t
  y(t) = v₀ * sin(θ) * t - 0.5 * g * t²
  Range: R = v₀² * sin(2θ) / g
```

**Rotational Dynamics**:
```
Constant torque τ on object with inertia I:
  α = τ / I
  ω(t) = ω₀ + α * t
  θ(t) = θ₀ + ω₀ * t + 0.5 * α * t²
```

### Test Scenarios

1. **Free Fall Test**: Drop object from 10m height, verify hits ground at `t = sqrt(20/9.81) ≈ 1.43s`
2. **Projectile Test**: Launch at 45° with v₀ = 10 m/s, verify range `R = 100/9.81 ≈ 10.2m`
3. **Rotation Test**: Apply constant torque, verify angular acceleration matches `α = τ / I`
4. **Combined Test**: Apply force at offset point, verify both translation and rotation

---

## Performance Characteristics

### Computational Complexity

**Per-object physics update**:
- Gravity application: O(1) — vector addition
- Force accumulation: O(k) where k = number of forces applied
- Linear integration: O(1) — vector operations
- Angular integration: O(1) — matrix-vector multiply (3x3 * 3x1)
- ReferenceFrame sync: O(1) — setOrigin + setRotation

**Total per frame**: O(n) where n = number of inertial objects

**Bottleneck analysis**:
- Matrix-vector multiply (`I⁻¹ * τ`) is the most expensive operation
- 3x3 matrix * 3x1 vector ≈ 15 FLOPs
- With Eigen optimizations (SIMD): ~5-10 CPU cycles
- Negligible compared to collision detection (O(n²) worst case)

### Memory Footprint

**Per AssetInertial object**:
- Existing members: ~200 bytes (hull, mass, inertia, state)
- Force accumulators (ticket 0023a): 48 bytes (2 * Coordinate)
- **No new allocations in this ticket**

**WorldModel**:
- No new members (gravity_ added in ticket 0023a)
- No heap allocations during physics update

### Expected Performance

**Target**: 1000 objects at 60 FPS
- Physics integration: ~1-2ms
- Frame budget: 16.67ms
- Physics overhead: < 10% of frame time

**Measurement plan**: Benchmark `WorldModel::updatePhysics()` with varying object counts to verify linear scaling.

---

## Future Enhancements (Out of Scope)

The following are intentionally deferred to future tickets:

1. **Collision Response**:
   - Impulse-based collision resolution
   - Coefficient of restitution (bounciness)
   - Friction forces
   - Ticket: TBD

2. **Advanced Integrators**:
   - Runge-Kutta 4th order (RK4) for better accuracy
   - Symplectic integrators for energy conservation
   - Adaptive timestep
   - Ticket: TBD

3. **Damping Forces**:
   - Linear drag: `F_drag = -k_linear * v`
   - Angular drag: `τ_drag = -k_angular * ω`
   - Ticket: TBD

4. **Quaternion Orientation**:
   - Replace AngularCoordinate with quaternions
   - Eliminates gimbal lock
   - More stable for large rotations
   - Ticket: TBD

5. **Constraint Solving**:
   - Joints (hinge, ball-socket, slider)
   - Springs and dampers
   - Ragdoll physics
   - Ticket: TBD

---

## Success Criteria

This design is complete when:
1. `AssetInertial::applyForceAtPoint()` torque computation is fully specified
2. `WorldModel::updatePhysics()` semi-implicit Euler integration is fully specified
3. ReferenceFrame synchronization logic is documented
4. Test requirements enumerate all physics behaviors to validate
5. Benchmark requirements specify performance targets
6. Physics validation section provides expected results for test scenarios
7. No new data members or API changes (only implementation completion)

The design will proceed to implementation only after human review and approval.

---

## Design Review

**Reviewer**: Design Review Agent
**Date**: 2026-01-21
**Status**: APPROVED
**Iteration**: 0 of 1 (no revision needed)

### Criteria Assessment

#### Architectural Fit

| Criterion | Pass/Fail | Notes |
|-----------|-----------|-------|
| Naming conventions | ✓ | Methods use camelCase (`applyForceAtPoint`, `updatePhysics`), members use snake_case_ (`accumulatedForce_`, `gravity_`), classes use PascalCase. Fully consistent with project standards. |
| Namespace organization | ✓ | All components in `msd_sim` namespace. File locations match established patterns: `msd/msd-sim/src/Physics/RigidBody/`, `msd/msd-sim/src/Environment/`. |
| File structure | ✓ | Modifies existing files in correct locations. No new files. AssetInertial in Physics/RigidBody, WorldModel in Environment matches layering. |
| Dependency direction | ✓ | AssetInertial depends on InertialState (Environment), WorldModel depends on AssetInertial (Physics). Correct layering: WorldModel → Physics → Environment. No circular dependencies. |

#### C++ Design Quality

| Criterion | Pass/Fail | Notes |
|-----------|-----------|-------|
| RAII usage | ✓ | No resources to manage - force accumulators are primitives. Existing scaffolding properly manages Eigen types. |
| Smart pointer appropriateness | ✓ | No smart pointers needed. Uses references (`InertialState&`, `ReferenceFrame&`) for non-owning access per project standards. Avoids shared_ptr as required. |
| Value/reference semantics | ✓ | Appropriate choices: value semantics for physics quantities (Coordinate, AngularRate), reference semantics for accessing components (getInertialState() returns reference). |
| Rule of 0/3/5 | ✓ | No new classes. Existing classes (AssetInertial, WorldModel) use Rule of Zero with compiler-generated special members. |
| Const correctness | ✓ | `getAccumulatedForce()` returns `const Coordinate&`. `getGravity()` is const method. Integration modifies state via non-const `InertialState&`. |
| Exception safety | ✓ | Basic exception safety guaranteed: force accumulation is transactional (either succeeds or state unchanged). Integration loop processes objects independently - failure in one doesn't corrupt others. |
| Initialization | ✓ | Design shows brace initialization: `Coordinate{0.0, 0.0, 0.0}`, `AngularRate{angularAccel}`. Force accumulators already initialized to zero in scaffolding. |
| Return values | ✓ | Follows project standard of returning values/structs. `getAccumulatedForce()` returns const reference (appropriate for non-owning access to existing data). |

#### Feasibility

| Criterion | Pass/Fail | Notes |
|-----------|-----------|-------|
| Header dependencies | ✓ | All required types already included. `AssetInertial.cpp` includes `InertialCalculations.hpp`, `ConvexHull.hpp`. `WorldModel.cpp` includes `AssetInertial.hpp`. No new circular dependencies. |
| Template complexity | ✓ | No templates introduced. Uses Eigen's expression templates correctly (already validated by existing code). |
| Memory strategy | ✓ | Zero heap allocations during physics update. All operations use stack-allocated temporaries and in-place modification of existing members. Force accumulators are inline members. |
| Thread safety | ✓ | Single-threaded simulation assumed per project standards. No thread-safety guarantees needed. Documented in WorldModel that it's not thread-safe. |
| Build integration | ✓ | Modifies existing source files only. No CMakeLists.txt changes. No new dependencies beyond existing Eigen3. |

#### Testability

| Criterion | Pass/Fail | Notes |
|-----------|-----------|-------|
| Isolation possible | ✓ | `applyForceAtPoint()` can be tested in isolation by calling it and checking `getAccumulatedTorque()`. `updatePhysics()` can be tested by setting up objects with known forces and verifying state updates. |
| Mockable dependencies | ✓ | `AssetInertial` is a concrete class but can be constructed with test fixtures. `ConvexHull` can be created from simple test geometry. No hidden dependencies on singletons or globals. |
| Observable state | ✓ | All physics state observable via getters: `getInertialState()`, `getAccumulatedForce()`, `getAccumulatedTorque()`, `getReferenceFrame()`. Test can verify position, velocity, orientation after integration. |

### Risks Identified

| ID | Risk Description | Category | Likelihood | Impact | Mitigation | Prototype? |
|----|------------------|----------|------------|--------|------------|------------|
| R1 | Numerical instability in semi-implicit Euler with large timesteps | Performance | Medium | Medium | Document timestep limits (16.67ms recommended). Future ticket for adaptive timestep if needed. Integration tests will verify stability at 60 FPS. | No |
| R2 | Energy drift over long simulations | Performance | High | Low | Expected behavior for Euler integrators (~1-2% drift). Documented in design. Acceptable for game/visualization applications. Future ticket for RK4/symplectic if precision required. | No |
| R3 | Inertia tensor inversion cost repeated every frame | Performance | Low | Low | Mitigated: `inverseInertiaTensor_` is cached at construction (line 34 of AssetInertial.cpp). Integration uses cached inverse, no per-frame inversion. | No |
| R4 | Orientation accumulation could lead to unnormalized angles | Technical | Medium | Low | Mitigated: `AngularCoordinate` uses deferred normalization with 100π threshold (ticket 0024). Normalization happens automatically in compound operators. | No |

### Risks NOT Requiring Prototypes

All identified risks have either been mitigated by design decisions or are inherent characteristics of the chosen integration algorithm (semi-implicit Euler). No prototypes needed because:

1. **R1 (timestep stability)**: Semi-implicit Euler is industry-standard for rigid body simulation at 60 FPS. Well-documented behavior.
2. **R2 (energy drift)**: Documented limitation of Euler integrators. Known and acceptable for application domain.
3. **R3 (inertia inversion)**: Already mitigated by cached inverse tensor in existing scaffolding.
4. **R4 (angle normalization)**: Already validated by prototypes in ticket 0024 (10x speedup, correctness verified).

### Summary

**APPROVED** — This design is ready to proceed to implementation.

**Strengths**:
- **Minimal scope**: Completes existing scaffolding without introducing new data structures or APIs
- **Well-established algorithms**: Semi-implicit Euler is industry-standard for game physics
- **Strong prerequisites**: Tickets 0023a (scaffolding) and 0024 (angular types) eliminate major risks
- **Comprehensive testing**: Detailed test plan covers unit, integration, and benchmark validation
- **Clear physics validation**: Provides exact formulas for verifying correctness (free fall, projectile motion, rotation)

**Physics correctness**: The design correctly implements:
- Torque from offset forces: `τ = r × F` (standard rigid body dynamics)
- Semi-implicit Euler: velocity-before-position update order (better stability than explicit)
- Linear integration: `a = F/m`, `v += a*dt`, `x += v*dt` (correct)
- Angular integration: `α = I⁻¹*τ`, `ω += α*dt`, `θ += ω*dt` (correct)
- Synchronization: `ReferenceFrame` updated after physics (maintains consistency)

**No blocking issues**. All identified risks have been addressed through design choices or are documented as known limitations with acceptable mitigation strategies.

**Recommended next steps**:
1. Human review and approval of design
2. Proceed directly to implementation (no prototype phase needed)
3. Implement as specified in design document
4. Validate with comprehensive test suite
