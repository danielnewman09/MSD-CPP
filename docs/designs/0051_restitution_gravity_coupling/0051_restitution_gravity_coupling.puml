@startuml
skinparam class {
    BackgroundColor<<new>> LightGreen
    BackgroundColor<<modified>> LightYellow
    BackgroundColor<<reused>> LightBlue
}

title Restitution-Gravity Coupling Fix: Velocity-Bias Architecture

package "WorldModel" {
  class WorldModel <<modified>> {
    +update(dt: double): void
    --
    {method} NEW: computeVelocityBias(dt: double): std::vector<InertialState>
  }

  note right of WorldModel::computeVelocityBias
    Computes per-body velocity bias from
    potential energies (gravity):

    v_bias = (F_potential / m) * dt
    ω_bias = (I^-1 * τ_potential) * dt

    Returns std::vector<InertialState> with
    only velocity fields populated.
    Position/orientation remain at defaults.

    No direct velocity mutation!
  end note
}

package "CollisionPipeline" {
  class CollisionPipeline <<modified>> {
    +execute(inertialAssets, environmentalAssets, dt, velocityBias): void
    --
    {method} MODIFIED: solveConstraintsWithWarmStart(dt, velocityBias): SolveResult
  }

  note right of CollisionPipeline::solveConstraintsWithWarmStart
    Passes velocityBias (std::optional<std::vector<InertialState>>)
    to ConstraintSolver
  end note
}

package "ConstraintSolver" {
  class ConstraintSolver <<modified>> {
    +solve(constraints, states, ..., dt, initialLambda, velocityBias): SolveResult
    --
    {method} MODIFIED: assembleRHS(constraints, jacobians, states, dt, velocityBias): Eigen::VectorXd
  }

  note right of ConstraintSolver::assembleRHS
    RHS with velocity bias (no restitution coupling):

    b_i = -(1+e_i) * J_i * v⁻_i  -  J_i * v_bias_i

    Extracts velocity from InertialState:
    - v_bias_i.velocity (linear)
    - v_bias_i.getAngularVelocity() (angular)

    Bias term NOT multiplied by (1+e), preventing
    restitution-gravity coupling.
  end note
}

package "msd-sim Types" {
  struct InertialState <<reused>> {
    +position: Coordinate
    +velocity: Vector3D
    +acceleration: Vector3D
    +orientation: QuaternionD
    +quaternionRate: Vector4D
    +angularAcceleration: AngularRate
    --
    +getAngularVelocity(): AngularRate
    +setAngularVelocity(omega: AngularRate): void
  }

  note right of InertialState
    REUSED for velocity bias (DD-0051-002)

    When used as bias:
    - velocity field populated
    - angular velocity via setAngularVelocity()
    - position, orientation, acceleration unused

    Benefit: Zero new types, consistent
    extraction pattern, future extensibility
  end note
}

' Relationships
WorldModel --> CollisionPipeline : execute(dt, velocityBias)
CollisionPipeline --> ConstraintSolver : solve(dt, velocityBias)
WorldModel ..> InertialState : creates (for bias)
CollisionPipeline ..> InertialState : passes (for bias)
ConstraintSolver ..> InertialState : extracts velocity (for bias)

@enduml
