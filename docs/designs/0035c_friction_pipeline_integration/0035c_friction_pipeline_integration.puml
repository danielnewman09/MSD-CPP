@startuml
skinparam class {
    BackgroundColor<<new>> LightGreen
    BackgroundColor<<modified>> LightYellow
}

package "Physics::RigidBody" {
  class AssetInertial <<modified>> {
    <<existing>>
    - coefficientOfRestitution_: double
    <<new>>
    - frictionCoefficient_: double

    <<existing>>
    + getCoefficientOfRestitution(): double
    + setCoefficientOfRestitution(double): void
    <<new>>
    + getFrictionCoefficient(): double
    + setFrictionCoefficient(double): void
  }

  class AssetEnvironment <<modified>> {
    <<existing>>
    - coefficientOfRestitution_: double
    <<new>>
    - frictionCoefficient_: double

    <<existing>>
    + getCoefficientOfRestitution(): double
    <<new>>
    + getFrictionCoefficient(): double
  }
}

package "Physics::Constraints" {
  ' Existing from 0032a
  class ContactConstraint {
    + dimension(): int {return 1}
    + evaluateTwoBody(): Eigen::VectorXd
    + jacobianTwoBody(): Eigen::MatrixXd
  }

  ' Existing from 0035a
  class FrictionConstraint {
    + dimension(): int {return 2}
    + evaluateTwoBody(): Eigen::VectorXd
    + jacobianTwoBody(): Eigen::MatrixXd
    + setNormalLambda(double): void
  }

  class ContactConstraintFactory <<modified>> {
    <<utility>>
    <<existing>>
    + createFromCollision(): vector<unique_ptr<ContactConstraint>>
    + combineRestitution(double, double): double
    + kRestVelocityThreshold: double = 0.5
    <<new>>
    + createFrictionConstraints(): vector<unique_ptr<FrictionConstraint>>
    + combineFrictionCoefficient(double, double): double
  }
}

package "Physics::Collision" <<existing>> {
  class CollisionResult {
    + contactCount: int
    + contactPointA: array<Coordinate, 4>
    + contactPointB: array<Coordinate, 4>
    + normal: Coordinate
    + penetrationDepth: double
  }

  ' Existing from 0035a
  class TangentBasis {
    <<utility>>
    + computeTangentBasis(normal): TangentFrame
  }
}

package "Environment" <<existing>> {
  class WorldModel <<modified>> {
    <<existing>>
    - integrator_: unique_ptr<Integrator>
    - potentialEnergies_: vector<PotentialEnergy*>

    <<existing>>
    + update(milliseconds): void
    <<modified>>
    - updateCollisions(dt): void


  }

    note right of WorldModel::updateCollisions
      Extended to create and solve
      friction constraints alongside
      normal contact constraints
    end note
}


' Relationships
AssetInertial --> ContactConstraintFactory : provides friction coefficient
AssetEnvironment --> ContactConstraintFactory : provides friction coefficient
ContactConstraintFactory ..> ContactConstraint : creates (1 per contact)
ContactConstraintFactory ..> FrictionConstraint : creates (1 per contact, if μ>0)
ContactConstraintFactory ..> CollisionResult : reads contact manifold
ContactConstraintFactory ..> TangentBasis : computes tangent frame
WorldModel ..> ContactConstraintFactory : uses for constraint creation
FrictionConstraint ..> TangentBasis : uses at construction

note top of ContactConstraintFactory
  **Extension for Friction** (Ticket 0035c)

  New method: createFrictionConstraints()
  - Calls TangentBasis::computeTangentBasis(normal)
  - Combines friction coefficients via geometric mean
  - Creates FrictionConstraint with μ_combined
  - Returns empty vector if μ = 0 (optimization)

  Integration in createFromCollision():
  - Create ContactConstraint (normal) per contact point
  - Create FrictionConstraint (tangential) per contact if μ > 0
  - Return unified constraint vector
end note

note top of AssetInertial
  **Friction Coefficient Property** (Ticket 0035c)

  Default: μ = 0.5 (moderate friction)
  Range: [0, ∞)

  Validation:
  - Constructor validates μ ≥ 0
  - Setter validates μ ≥ 0

  Integration:
  - Passed to ContactConstraintFactory
  - Combined with other body's μ via geometric mean
end note

note top of WorldModel
  **Friction Integration in updateCollisions()** (Ticket 0035c)

  For each collision:
  1. Create normal ContactConstraints (existing)
  2. Create friction FrictionConstraints (new, if μ > 0)
  3. Pass all constraints to ConstraintSolver::solveWithContacts()
  4. Solver dispatches to ECOS if friction detected (ticket 0035b4)
  5. Apply resulting forces to bodies

  Optimization: Skip friction creation if μ_combined = 0
end note

@enduml
